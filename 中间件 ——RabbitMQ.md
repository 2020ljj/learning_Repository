# 中间件 ——RabbitMQ

### 1.RabbitMQ介绍

RabbitMQ是在AMQP基础上实现的，可以用于系统各个模块的高效通信、支持高并发和可扩展。

​	RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。

### 2.RabbitMQ使用场景

三个：**异步**、**削峰**、**解耦**

异步：验证码、短信、邮件 、 mysql和redis/es数据同步

解耦：分布式

削峰：

### 重要：

### 一、RabbitMQ如何保证消息不丢失？

##### 1.生产者确认机制

消息发送到MQ之后，会返回一个结果给发送者，表示消息是否处理成功：如发送方发送消息给交换机时丢失，会返回一个nack publish-confirm , 交换机发送给mq丢失，会返回一个ack publish-return.

​	消息发送失败后：① 回调方法立刻重发 ② 记录日志 ③ 保存到数据库中，定时重发

##### 2.消息持久化

情景：消息到mq后，mq宕机了，消息有危险丢失

MQ默认内存存储消息，开启持久化功能可以确保缓存在mq中的消息不丢失

①交换机持久化 ②队列持久化 ③消息持久化

##### 3.消费者确认

消费者处理消息后可以向mq发送ack回执，mq收到ack回执后才会删除该消息，SpringAMQP允许配置三种确认模式：manual（ack）、**auto**（自动ack★）、none（关闭ack）

##### 4.消费者出现异常时利用本地重试

设置重试次数,当次数到达了之后,会将消息投递到异常交换机,交由人工处理



### 二、消息的重复消费问题？

消费者在消费一条消息后，如果出现**网络抖动**或者**消费者挂了**，导致mq没有接到消费者自动确认，这时候消费者认为自己已经消费了消息a，但消息队列中却没有删除消息a，就会出现重复消费。

##### 解决：

①每个消息设置一个唯一id★

②分布式锁、数据库锁

### 三、死信交换机（RabbitMQ延迟队列）

**延迟队列**  =  **死信交换机** + **TTL**（存活时间）

 成为死信的三种方式：

①消费者使用reject或者nack声明消费失败 ， 并且消息的requeue参数设置为false

②消息过期，无人消费

③要投递的队列消息满了，最早的消息将成为死信

### 四、消息堆积怎么解决（如果RabbitMQ中有100万消息堆积在MQ，如何解决？）

当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储达到上限，后面发送的消息就会成为死信，会被丢弃

**解决：**

①增加消费者

②在消费者内开启线程池加快消息处理速度

③扩大队列容积，提高堆积上限

④**惰性队列**

