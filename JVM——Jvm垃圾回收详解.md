### JVM——Jvm垃圾回收详解

![image-20230801155757426](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230801155757426.png)

##### 																		 图：堆内存结构

### 堆空间的基本结构

java堆是垃圾收集器管理的主要区域，也被称为**GC堆**；从回收的角度来说，现在收集器都采用分代垃圾收集算法，根据各个区域的特点选择合适的垃圾收集算法。

jdk8版本：堆空间被分为如下三部分：**新生代内存**、**老生代**以及**元空间**（使用直接内存）

### 内存分配和回收原则

1.对象优先在Eden区域分配：当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC，通过 **分配担保机制** 把新生代的对象提前转移到老年代中去

2.大对象直接进入老年代：如字符串、数组

3.长期存活的对象将进入老年代：
大多数情况下，对象首先在Eden区域分配，如果对象在Eden区出生并经过第一次MinorGC后仍然存活，且可以被Survivor容纳的话，就移动到Survivor（s0/s1）空间，并将对象的年龄设为1；接着，对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。

总结：针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

- 部分收集：
  - 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
  - 老年代收集
  - 混合收集
- 整堆收集（Full GC）:收集整个Java堆和方法区

### 对象死亡判断方法

#### 1.引用计数法：

每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**缺陷**：很难解决对象之间循环引用的问题

#### 2.可达性分析算法：

通过一系列称为"GC Roots"的对象作为起点，从这些起点开始向下搜索，当节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

可以被作为GCRoots的对象：虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象以及所有被同步锁持有的对象

### 引用类型总结

jvm会对不同类型的引用的创建销毁做不同的处理，引用分为四种:**强引用**、**软引用**、**弱引用**、**虚引用**四种。强引用的对象正常情况下不会被回收，当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止；软引用的对象会在内存空间不足时被回收，而弱引用的对象在下一次 gc 的时候就会被回收，不论当前内存是否足够，虚引用形同虚设，任何时候都可能被垃圾回收。

**注**：1.**虚引用主要用来跟踪对象被垃圾回收的活动**。虚引用与软引用和弱引用的一个区别在于， 虚引用必须和引用队列（ReferenceQueue）联合使用，程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。

​		2.弱引用和虚引用使用较少，软引用使用较多，因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。**软引用最常用于实现内存敏感缓存，当堆内存不足时，释放缓存空间。**

### 如何判断一个常量是废弃常量？

当前没有任何对象引用该常量时

### 如何判断一个类是无用的类？

- 1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 2. 加载该类的 `ClassLoader` 已经被回收。
- 3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法

#### 1.标记-清除算法

- **效率问题**：标记和清除两个过程效率都不高。
- **空间问题**：标记清除后会产生大量不连续的内存碎片。

#### 2.复制算法

- **可用内存变小**：可用内存缩小为原来的一半。
- **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差

#### 3.标记-整理算法

让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。多了整理这一步，因此效率也不高，**适合老年代这种垃圾回收频率不是很高的场景**

### 垃圾收集器

没有万能的垃圾收集器，需要根据具体的应用场景选择适合的垃圾收集器

#### 1. Serial收集器

新生代采用标记-复制算法，老年代采用标记-整理算法。

**优点**：**简单而高效（与其他收集器的单线程相比）**，没有线程开销

#### 2. ParNew 收集器

Serial 收集器的多线程版本

#### 3. Parallel Scavenge 收集器

新生代采用标记-复制算法，老年代采用标记-整理算法。

Parallel Scavenge 收集器也是使用**标记-复制**算法的多线程收集器：关注点是吞吐量（高效率的利用 CPU）

JDK1.8默认使用的是 Parallel Scavenge + Parallel Old

#### 4. Serial Old收集器

Serial收集器的老年代版本

#### 5. ParNew 收集器

Parallel Scavenge 收集器的老年代版本

#### 6. CMS 收集器

CMS收集器是一款是一种以获取最短回收停顿时间为目标的收集器，是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

CMS 收集器是一种 **“标记-清除”算法**实现的，运作过程分为四步：**初始标记**（记录下直接与 root 相连的对象）、**并发标记**（跟踪记录发生引用更新的地方）、**重新标记**（修正并发标记期间产生的变动）、并发清除

**优点：**并发收集、低停顿。

**缺点：**对 CPU 资源敏感；无法处理浮动垃圾；它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

#### 7. G1收集器

G1 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。从JDK9开始，成为**默认的垃圾收集器**

具备以下特点：**并行与并发**、**分代收集**、**空间整合**、**可预测的停顿**

大致有以下步骤：**初始标记**、**并发标记**、**最终标记**、**筛选回收**

**G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region**